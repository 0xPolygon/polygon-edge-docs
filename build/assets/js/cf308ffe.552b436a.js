(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{103:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return o})),t.d(n,"metadata",(function(){return i})),t.d(n,"toc",(function(){return c})),t.d(n,"default",(function(){return p}));var a=t(3),r=t(7),s=(t(0),t(112)),o={id:"consensus",title:"Consensus"},i={unversionedId:"reference/modules/consensus",id:"reference/modules/consensus",isDocsHomePage:!1,title:"Consensus",description:"Overview",source:"@site/docs/reference/modules/consensus.md",slug:"/reference/modules/consensus",permalink:"/docs/reference/modules/consensus",editUrl:"https://github.com/0xPolygon/polygon-sdk-docs/docs/reference/modules/consensus.md",version:"current",sidebar:"reference",previous:{title:"JSON RPC",permalink:"/docs/reference/modules/json-rpc"},next:{title:"Storage",permalink:"/docs/reference/modules/storage"}},c=[{value:"Overview",id:"overview",children:[]},{value:"Consensus Interface",id:"consensus-interface",children:[]},{value:"Consensus Configuration",id:"consensus-configuration",children:[]},{value:"IBFT",id:"ibft",children:[{value:"ExtraData",id:"extradata",children:[]},{value:"Signing Data",id:"signing-data",children:[]},{value:"Snapshots",id:"snapshots",children:[]},{value:"IBFT Startup",id:"ibft-startup",children:[]},{value:"IBFT States",id:"ibft-states",children:[]}]}],l={toc:c};function p(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(s.b)("wrapper",Object(a.a)({},l,t,{components:n,mdxType:"MDXLayout"}),Object(s.b)("h2",{id:"overview"},"Overview"),Object(s.b)("p",null,"The ",Object(s.b)("strong",{parentName:"p"},"Consensus")," module provides an interface for consensus mechanisms."),Object(s.b)("p",null,"Currently, the following consensus engines are being worked on:"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},Object(s.b)("strong",{parentName:"li"},"IBFT"),"      \u2705"),Object(s.b)("li",{parentName:"ul"},Object(s.b)("strong",{parentName:"li"},"Clique"),"    (\u26a0\ufe0f",Object(s.b)("strong",{parentName:"li"},"WIP"),")"),Object(s.b)("li",{parentName:"ul"},Object(s.b)("strong",{parentName:"li"},"Ethash"),"    (\u26a0\ufe0f",Object(s.b)("strong",{parentName:"li"},"WIP"),")"),Object(s.b)("li",{parentName:"ul"},Object(s.b)("strong",{parentName:"li"},"PoW"),"       (\u26a0\ufe0f",Object(s.b)("strong",{parentName:"li"},"WIP"),")")),Object(s.b)("p",null,"The Polygon SDK wants to maintain a state of modularity and pluggability. ",Object(s.b)("br",null),"\nThis is why the core consensus logic has been abstracted away, so new consensus mechanisms can be built on top, without\ncompromising on usability and ease of use."),Object(s.b)("h2",{id:"consensus-interface"},"Consensus Interface"),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-go",metastring:'title="consensus/consensus.go"',title:'"consensus/consensus.go"'},"// Consensus is the interface for consensus\ntype Consensus interface {\n    // VerifyHeader verifies the header is correct\n    VerifyHeader(parent, header *types.Header) error\n\n    // Start starts the consensus\n    Start() error\n\n    // Close closes the connection\n    Close() error\n}\n")),Object(s.b)("p",null,"The ",Object(s.b)("strong",{parentName:"p"},Object(s.b)("em",{parentName:"strong"},"Consensus"))," interface is the core of the mentioned abstraction. ",Object(s.b)("br",null)),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"The ",Object(s.b)("strong",{parentName:"li"},"VerifyHeader")," method represents a helper function which the consensus layer exposes to the ",Object(s.b)("strong",{parentName:"li"},"blockchain")," layer\nIt is there to handle header verification"),Object(s.b)("li",{parentName:"ul"},"The ",Object(s.b)("strong",{parentName:"li"},"Start")," method simply starts the consensus process, and everything associated with it. This includes synchronization,\nsealing, everything that needs to be done"),Object(s.b)("li",{parentName:"ul"},"The ",Object(s.b)("strong",{parentName:"li"},"Close")," method closes the consensus connection")),Object(s.b)("h2",{id:"consensus-configuration"},"Consensus Configuration"),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-go",metastring:'title="consensus/consensus.go"',title:'"consensus/consensus.go"'},"// Config is the configuration for the consensus\ntype Config struct {\n    // Logger to be used by the backend\n    Logger *log.Logger\n\n    // Params are the params of the chain and the consensus\n    Params *chain.Params\n\n    // Specific configuration parameters for the backend\n    Config map[string]interface{}\n\n    // Path for the consensus protocol to store information\n    Path string\n}\n")),Object(s.b)("p",null,"There may be times when you might want to pass in a custom location for the consensus protocol to store data, or perhaps\na custom key-value map which you want the consensus mechanism to use. This can be achieved through the ",Object(s.b)("strong",{parentName:"p"},Object(s.b)("em",{parentName:"strong"},"Config"))," struct,\nwhich gets read when a new consensus instance is created."),Object(s.b)("h2",{id:"ibft"},"IBFT"),Object(s.b)("h3",{id:"extradata"},"ExtraData"),Object(s.b)("p",null,"The blockchain header object, among other fields, has a field called ",Object(s.b)("strong",{parentName:"p"},"ExtraData"),". ",Object(s.b)("br",null),"\nTo review the fields present in the block header, please check out the ",Object(s.b)("strong",{parentName:"p"},Object(s.b)("a",{parentName:"strong",href:"/docs/guides/ethereum-state#blocks"},"State in Ethereum"))," section."),Object(s.b)("p",null,"IBFT uses this extra field to store operational information regarding the block, answering questions like:"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},'"Who signed this block?"'),Object(s.b)("li",{parentName:"ul"},'"Who are the validators for this block?"')),Object(s.b)("p",null,"These extra fields for IBFT are defined as follows:"),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-go",metastring:'title="consensus/ibft/extra.go"',title:'"consensus/ibft/extra.go"'},"type IstanbulExtra struct {\n    Validators    []types.Address\n    Seal          []byte\n    CommittedSeal [][]byte\n}\n")),Object(s.b)("h3",{id:"signing-data"},"Signing Data"),Object(s.b)("p",null,"In order for the node to sign information in IBFT, it leverages the ",Object(s.b)("em",{parentName:"p"},"signHash")," method:"),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-go",metastring:'title="consensus/ibft/sign.go"',title:'"consensus/ibft/sign.go"'},"func signHash(h *types.Header) ([]byte, error) {\n    //hash := istambulHeaderHash(h)\n    //return hash.Bytes(), nil\n\n    h = h.Copy() // make a copy since we update the extra field\n\n    arena := fastrlp.DefaultArenaPool.Get()\n    defer fastrlp.DefaultArenaPool.Put(arena)\n\n    // when hashign the block for signing we have to remove from\n    // the extra field the seal and commitedseal items\n    extra, err := getIbftExtra(h)\n    if err != nil {\n        return nil, err\n    }\n    putIbftExtraValidators(h, extra.Validators)\n\n    vv := arena.NewArray()\n    vv.Set(arena.NewBytes(h.ParentHash.Bytes()))\n    vv.Set(arena.NewBytes(h.Sha3Uncles.Bytes()))\n    vv.Set(arena.NewBytes(h.Miner.Bytes()))\n    vv.Set(arena.NewBytes(h.StateRoot.Bytes()))\n    vv.Set(arena.NewBytes(h.TxRoot.Bytes()))\n    vv.Set(arena.NewBytes(h.ReceiptsRoot.Bytes()))\n    vv.Set(arena.NewBytes(h.LogsBloom[:]))\n    vv.Set(arena.NewUint(h.Difficulty))\n    vv.Set(arena.NewUint(h.Number))\n    vv.Set(arena.NewUint(h.GasLimit))\n    vv.Set(arena.NewUint(h.GasUsed))\n    vv.Set(arena.NewUint(h.Timestamp))\n    vv.Set(arena.NewCopyBytes(h.ExtraData))\n\n    buf := keccak.Keccak256Rlp(nil, vv)\n    return buf, nil\n}\n")),Object(s.b)("p",null,"Another notable method is the ",Object(s.b)("em",{parentName:"p"},"VerifyCommittedFields")," method, which verifies that the committed seals are from valid validators:"),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-go",metastring:'title="consensus/ibft/sign.go',title:'"consensus/ibft/sign.go'},'func verifyCommitedFields(snap *Snapshot, header *types.Header) error {\n    extra, err := getIbftExtra(header)\n    if err != nil {\n        return err\n    }\n    if len(extra.CommittedSeal) == 0 {\n        return fmt.Errorf("empty committed seals")\n    }\n\n    // get the message that needs to be signed\n    signMsg, err := signHash(header)\n    if err != nil {\n        return err\n    }\n    signMsg = commitMsg(signMsg)\n\n    visited := map[types.Address]struct{}{}\n    for _, seal := range extra.CommittedSeal {\n        addr, err := ecrecoverImpl(seal, signMsg)\n        if err != nil {\n            return err\n        }\n\n        if _, ok := visited[addr]; ok {\n            return fmt.Errorf("repeated seal")\n        } else {\n            if !snap.Set.Includes(addr) {\n                return fmt.Errorf("signed by non validator")\n            }\n            visited[addr] = struct{}{}\n        }\n    }\n\n    validSeals := len(visited)\n    if validSeals <= 2*snap.Set.MinFaultyNodes() {\n        return fmt.Errorf("not enough seals to seal block")\n    }\n    return nil\n}\n')),Object(s.b)("h3",{id:"snapshots"},"Snapshots"),Object(s.b)("p",null,"Snapshots, as the name implies, are there to provide a ",Object(s.b)("em",{parentName:"p"},"snapshot"),", or the ",Object(s.b)("em",{parentName:"p"},"state")," of a system at any block height (number)."),Object(s.b)("p",null,"Snapshots contain a set of nodes who are validators, as well as voting information (validators can vote for other validators).\nValidators include voting information in the ",Object(s.b)("strong",{parentName:"p"},"Miner")," header filed, and change the value of the ",Object(s.b)("strong",{parentName:"p"},"nonce"),":"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"Nonce is ",Object(s.b)("strong",{parentName:"li"},"all 1s")," if the node wants to remove a validator"),Object(s.b)("li",{parentName:"ul"},"Nonce is ",Object(s.b)("strong",{parentName:"li"},"all 0s")," if the node wants to add a validator")),Object(s.b)("p",null,"Snapshots are calculated using the ",Object(s.b)("strong",{parentName:"p"},Object(s.b)("em",{parentName:"strong"},"processHeaders"))," method:"),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-go",metastring:'title="consensus/ibft/snapshot.go"',title:'"consensus/ibft/snapshot.go"'},'func (i *Ibft) processHeaders(headers []*types.Header) error {\n    if len(headers) == 0 {\n        return nil\n    }\n\n    parentSnap, err := i.getSnapshot(headers[0].Number - 1)\n    if err != nil {\n        return err\n    }\n    snap := parentSnap.Copy()\n\n    saveSnap := func(h *types.Header) error {\n        if snap.Equal(parentSnap) {\n            return nil\n        }\n\n        snap.Number = h.Number\n        snap.Hash = h.Hash.String()\n\n        i.store.add(snap)\n\n        parentSnap = snap\n        snap = parentSnap.Copy()\n        return nil\n    }\n\n    for _, h := range headers {\n        number := h.Number\n\n        validator, err := ecrecoverFromHeader(h)\n        if err != nil {\n            return err\n        }\n        if !snap.Set.Includes(validator) {\n            return fmt.Errorf("unauthroized validator")\n        }\n\n        if number%i.epochSize == 0 {\n            // during a checkpoint block, we reset the voles\n            // and there cannot be any proposals\n            snap.Votes = nil\n            if err := saveSnap(h); err != nil {\n                return err\n            }\n\n            // remove in-memory snaphots from two epochs before this one\n            epoch := int(number/i.epochSize) - 2\n            if epoch > 0 {\n                purgeBlock := uint64(epoch) * i.epochSize\n                i.store.deleteLower(purgeBlock)\n            }\n            continue\n        }\n\n        // if we have a miner address, this might be a vote\n        if h.Miner == types.ZeroAddress {\n            continue\n        }\n\n        // the nonce selects the action\n        var authorize bool\n        if h.Nonce == nonceAuthVote {\n            authorize = true\n        } else if h.Nonce == nonceDropVote {\n            authorize = false\n        } else {\n            return fmt.Errorf("incorrect vote nonce")\n        }\n\n        // validate the vote\n        if authorize {\n            // we can only authorize if they are not on the validators list\n            if snap.Set.Includes(h.Miner) {\n                continue\n            }\n        } else {\n            // we can only remove if they are part of the validators list\n            if !snap.Set.Includes(h.Miner) {\n                continue\n            }\n        }\n\n        count := snap.Count(func(v *Vote) bool {\n            return v.Validator == validator && v.Address == h.Miner\n        })\n        if count > 1 {\n            // there can only be one vote per validator per address\n            return fmt.Errorf("more than one proposal per validator per address found")\n        }\n        if count == 0 {\n            // cast the new vote since there is no one yet\n            snap.Votes = append(snap.Votes, &Vote{\n                Validator: validator,\n                Address:   h.Miner,\n                Authorize: authorize,\n            })\n        }\n\n        // check the tally for the proposed validator\n        tally := snap.Count(func(v *Vote) bool {\n            return v.Address == h.Miner\n        })\n\n        if tally > snap.Set.Len()/2 {\n            if authorize {\n                // add the proposal to the validator list\n                snap.Set.Add(h.Miner)\n            } else {\n                // remove the proposal from the validators list\n                snap.Set.Del(h.Miner)\n\n                // remove any votes casted by the removed validator\n                snap.RemoveVotes(func(v *Vote) bool {\n                    return v.Validator == h.Miner\n                })\n            }\n\n            // remove all the votes that promoted this validator\n            snap.RemoveVotes(func(v *Vote) bool {\n                return v.Address == h.Miner\n            })\n        }\n\n        if err := saveSnap(h); err != nil {\n            return nil\n        }\n    }\n\n    // update the metadata\n    i.store.updateLastBlock(headers[len(headers)-1].Number)\n    return nil\n}\n')),Object(s.b)("p",null,"This method is usually called with 1 header, but the flow is the same even with multiple headers. ",Object(s.b)("br",null),"\nFor each passed in header, IBFT needs to verify that the proposer of the header is the validator. This can be done easily by\ngrabbing the latest snapshot, and checking if the node is in the validator set."),Object(s.b)("p",null,"Next, the nonce is checked. The vote is included, and tallied - and if there are enough votes a node is added / removed from\nthe validator set, following which the new snapshot is saved."),Object(s.b)("h4",{id:"snapshot-store"},"Snapshot Store"),Object(s.b)("p",null,"The snapshot service manages and updates an entity called the ",Object(s.b)("strong",{parentName:"p"},"snapshotStore"),", which stores the list of all available snapshots.\nUsing it, the service is able to quickly figure out which snapshot is associated with which block height."),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-go",metastring:'title="consensus/ibft/snapshot.go"',title:'"consensus/ibft/snapshot.go"'},"type snapshotStore struct {\n    lastNumber uint64\n    lock       sync.Mutex\n    list       snapshotSortedList\n}\n")),Object(s.b)("h3",{id:"ibft-startup"},"IBFT Startup"),Object(s.b)("p",null,"To start up IBFT, the Polygon SDK firstly needs to set up the IBFT transport:"),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-go",metastring:'title="consensus/ibft/ibft.go"',title:'"consensus/ibft/ibft.go"'},'func (i *Ibft) setupTransport() error {\n    // use a gossip protocol\n    topic, err := i.network.NewTopic(ibftProto, &proto.MessageReq{})\n    if err != nil {\n        return err\n    }\n\n    err = topic.Subscribe(func(obj interface{}) {\n        msg := obj.(*proto.MessageReq)\n\n        if !i.isSealing() {\n            // if we are not sealing we do not care about the messages\n            // but we need to subscribe to propagate the messages\n            return\n        }\n\n        // decode sender\n        if err := validateMsg(msg); err != nil {\n            i.logger.Error("failed to validate msg", "err", err)\n            return\n        }\n\n        if msg.From == i.validatorKeyAddr.String() {\n            // we are the sender, skip this message since we already\n            // relay our own messages internally.\n            return\n        }\n        i.pushMessage(msg)\n    })\n    if err != nil {\n        return err\n    }\n\n    i.transport = &gossipTransport{topic: topic}\n    return nil\n}\n')),Object(s.b)("p",null,"It essentially creates a new topic with IBFT proto, with a new proto buff message.",Object(s.b)("br",null),"\nThe messages are meant to be used by validators. The Polygon SDK then subscribes to the topic, and handles messages accordingly."),Object(s.b)("h4",{id:"messagereq"},"MessageReq"),Object(s.b)("p",null,"The message exchanged by validators:"),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-go",metastring:'title="consensus/ibft/proto/ibft.proto"',title:'"consensus/ibft/proto/ibft.proto"'},"message MessageReq {\n    // type is the type of the message\n    Type type = 1;\n\n    // from is the address of the sender\n    string from = 2;\n\n    // seal is the committed seal if message is commit\n    string seal = 3;\n\n    // signature is the crypto signature of the message\n    string signature = 4;\n\n    // view is the view assigned to the message\n    View view = 5;\n\n    // hash of the locked block\n    string digest = 6;\n\n    // proposal is the rlp encoded block in preprepare messages\n    google.protobuf.Any proposal = 7;\n\n    enum Type {\n        Preprepare = 0;\n        Prepare = 1;\n        Commit = 2;\n        RoundChange = 3;\n    }\n}\n\nmessage View {\n    uint64 round = 1;\n    uint64 sequence = 2;\n}\n")),Object(s.b)("p",null,"The ",Object(s.b)("strong",{parentName:"p"},"View")," field in the ",Object(s.b)("strong",{parentName:"p"},"MessageReq")," represents the current node position inside the chain.\nIt has a ",Object(s.b)("em",{parentName:"p"},"round"),", and a ",Object(s.b)("em",{parentName:"p"},"sequence")," attribute."),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},Object(s.b)("strong",{parentName:"li"},"round")," represents the proposer round for the height"),Object(s.b)("li",{parentName:"ul"},Object(s.b)("strong",{parentName:"li"},"sequence")," represents the height of the blockchain")),Object(s.b)("p",null,"The ",Object(s.b)("em",{parentName:"p"},"msgQueue")," filed in the IBFT implementation has the purpose of storing message requests. It orders messages by\nthe ",Object(s.b)("em",{parentName:"p"},"View")," (firstly by sequence, then by round). The IBFT implementation also possesses different queues for different states in the system."),Object(s.b)("h3",{id:"ibft-states"},"IBFT States"),Object(s.b)("p",null,"After the consensus mechanism is started using the ",Object(s.b)("strong",{parentName:"p"},"Start")," method, it runs into an infinite loop which simulates a state machine:"),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-go",metastring:'title="consensus/ibft/ibft.go"',title:'"consensus/ibft/ibft.go"'},'func (i *Ibft) start() {\n    // consensus always starts in SyncState mode in case it needs\n    // to sync with other nodes.\n    i.setState(SyncState)\n\n    header := i.blockchain.Header()\n    i.logger.Debug("current sequence", "sequence", header.Number+1)\n\n    for {\n        select {\n        case <-i.closeCh:\n            return\n        default:\n        }\n\n        i.runCycle()\n    }\n}\n\nfunc (i *Ibft) runCycle() {\n    if i.state.view != nil {\n        i.logger.Debug(\n            "cycle", \n            "state", \n            i.getState(), \n            "sequence", \n            i.state.view.Sequence, \n            "round", \n            i.state.view.Round,\n        )\n    }\n\n    switch i.getState() {\n    case AcceptState:\n        i.runAcceptState()\n\n    case ValidateState:\n        i.runValidateState()\n\n    case RoundChangeState:\n        i.runRoundChangeState()\n\n    case SyncState:\n        i.runSyncState()\n    }\n}\n')),Object(s.b)("h4",{id:"syncstate"},"SyncState"),Object(s.b)("p",null,"All nodes initially start in the ",Object(s.b)("strong",{parentName:"p"},"Sync")," state."),Object(s.b)("p",null,"This is because fresh data needs to be fetched from the blockchain. The client needs to find out if it's the validator,\nfind the current snapshot. This state resolves any pending blocks."),Object(s.b)("p",null,"After the sync finishes, and the client determines it is indeed a validator, it needs to transfer to ",Object(s.b)("strong",{parentName:"p"},"AcceptState"),".\nIf the client is ",Object(s.b)("strong",{parentName:"p"},"not")," a validator, it will continue syncing, and stay in ",Object(s.b)("strong",{parentName:"p"},"SyncState")),Object(s.b)("h4",{id:"acceptstate"},"AcceptState"),Object(s.b)("p",null,"The ",Object(s.b)("strong",{parentName:"p"},"Accept")," state always check the snapshot, and the validator set. If the current node is not in the validators set,\nit moves back to the ",Object(s.b)("strong",{parentName:"p"},"Sync")," state."),Object(s.b)("p",null,"On the other hand, if the node ",Object(s.b)("strong",{parentName:"p"},"is")," a validator, it calculates the proposer. If it turns out that the current node is the\nproposer, it builds a block, and sends preprepare and then prepare messages."),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"Preprepare messages - messages sent by proposers to validators, to let them know about the proposal"),Object(s.b)("li",{parentName:"ul"},"Prepare messages - messages where validators agree on a proposal. All nodes receive all prepare messages"),Object(s.b)("li",{parentName:"ul"},"Commit messages - messages containing commit information for the proposal")),Object(s.b)("p",null,"If the current node ",Object(s.b)("strong",{parentName:"p"},"is not")," a validator, it uses the ",Object(s.b)("em",{parentName:"p"},"getNextMessage")," method to read a message from the previously shown queue. ",Object(s.b)("br",null),"\nIt waits for the preprepare messages. Once it is confirmed everything is correct, the node moves to the ",Object(s.b)("strong",{parentName:"p"},"Validate")," state."),Object(s.b)("h4",{id:"validatestate"},"ValidateState"),Object(s.b)("p",null,"The ",Object(s.b)("strong",{parentName:"p"},"Validate")," state is rather simple - all nodes do in this state is read messages and add them to their local snapshot state. "))}p.isMDXComponent=!0},112:function(e,n,t){"use strict";t.d(n,"a",(function(){return u})),t.d(n,"b",(function(){return d}));var a=t(0),r=t.n(a);function s(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){s(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=r.a.createContext({}),p=function(e){var n=r.a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=p(e.components);return r.a.createElement(l.Provider,{value:n},e.children)},h={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},b=r.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,s=e.originalType,o=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),u=p(t),b=a,d=u["".concat(o,".").concat(b)]||u[b]||h[b]||s;return t?r.a.createElement(d,i(i({ref:n},l),{},{components:t})):r.a.createElement(d,i({ref:n},l))}));function d(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var s=t.length,o=new Array(s);o[0]=b;var i={};for(var c in n)hasOwnProperty.call(n,c)&&(i[c]=n[c]);i.originalType=e,i.mdxType="string"==typeof e?e:a,o[1]=i;for(var l=2;l<s;l++)o[l]=t[l];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,t)}b.displayName="MDXCreateElement"}}]);