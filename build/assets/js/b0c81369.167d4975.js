(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{101:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return b}));var r=n(0),o=n.n(r);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=o.a.createContext({}),p=function(e){var t=o.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return o.a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},m=o.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,s=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),u=p(n),m=r,b=u["".concat(s,".").concat(m)]||u[m]||d[m]||a;return n?o.a.createElement(b,i(i({ref:t},l),{},{components:n})):o.a.createElement(b,i({ref:t},l))}));function b(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,s=new Array(a);s[0]=m;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var l=2;l<a;l++)s[l]=n[l];return o.a.createElement.apply(null,s)}return o.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},91:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return i})),n.d(t,"toc",(function(){return c})),n.d(t,"default",(function(){return p}));var r=n(3),o=n(7),a=(n(0),n(101)),s={id:"txpool",title:"TxPool"},i={unversionedId:"reference/modules/txpool",id:"reference/modules/txpool",isDocsHomePage:!1,title:"TxPool",description:"Overview",source:"@site/docs/reference/modules/txpool.md",slug:"/reference/modules/txpool",permalink:"/docs/reference/modules/txpool",editUrl:"https://github.com/0xPolygon/polygon-sdk-docs/docs/reference/modules/txpool.md",version:"current",sidebar:"develop",previous:{title:"State",permalink:"/docs/reference/modules/state"},next:{title:"JSON RPC",permalink:"/docs/reference/modules/json-rpc"}},c=[{value:"Overview",id:"overview",children:[]},{value:"Operator Commands",id:"operator-commands",children:[]},{value:"Processing Transactions",id:"processing-transactions",children:[]},{value:"Data structures",id:"data-structures",children:[]}],l={toc:c};function p(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(a.b)("wrapper",Object(r.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h2",{id:"overview"},"Overview"),Object(a.b)("p",null,"The TxPool module represents the transaction pool implementation, where transactions are added from different parts of\nthe system. The module also exposes several useful features for node operators, which are covered below."),Object(a.b)("h2",{id:"operator-commands"},"Operator Commands"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-go",metastring:'title="txpool/proto/operator.proto',title:'"txpool/proto/operator.proto'},"service TxnPoolOperator {\n    // Status returns the current status of the pool\n    rpc Status(google.protobuf.Empty) returns (TxnPoolStatusResp);\n\n    // AddTxn adds a local transaction to the pool\n    rpc AddTxn(AddTxnReq) returns (google.protobuf.Empty);\n\n    // Subscribe subscribes for new events in the txpool\n    rpc Subscribe(google.protobuf.Empty) returns (stream TxPoolEvent);\n}\n\n")),Object(a.b)("p",null,"Node operators can query these GRPC endpoints, as described in the ",Object(a.b)("strong",{parentName:"p"},Object(a.b)("a",{parentName:"strong",href:"/docs/cli-commands#transaction-pool-commands"},"CLI Commands"))," section."),Object(a.b)("h2",{id:"processing-transactions"},"Processing Transactions"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-go",metastring:'title="txpool/txpool.go"',title:'"txpool/txpool.go"'},'// AddTx adds a new transaction to the pool\nfunc (t *TxPool) AddTx(tx *types.Transaction) error {\n    if err := t.addImpl("addTxn", tx); err != nil {\n        return err\n    }\n\n    // broadcast the transaction only if network is enabled\n    // and we are not in dev mode\n    if t.topic != nil && !t.dev {\n        txn := &proto.Txn{\n            Raw: &any.Any{\n                Value: tx.MarshalRLP(),\n            },\n        }\n        if err := t.topic.Publish(txn); err != nil {\n            t.logger.Error("failed to topic txn", "err", err)\n        }\n    }\n\n    if t.NotifyCh != nil {\n        select {\n        case t.NotifyCh <- struct{}{}:\n        default:\n        }\n    }\n    return nil\n}\n\nfunc (t *TxPool) addImpl(ctx string, txns ...*types.Transaction) error {\n    if len(txns) == 0 {\n        return nil\n    }\n\n    from := txns[0].From\n    for _, txn := range txns {\n        // Since this is a single point of inclusion for new transactions both\n        // to the promoted queue and pending queue we use this point to calculate the hash\n        txn.ComputeHash()\n\n        err := t.validateTx(txn)\n        if err != nil {\n            return err\n        }\n\n        if txn.From == types.ZeroAddress {\n            txn.From, err = t.signer.Sender(txn)\n            if err != nil {\n                return fmt.Errorf("invalid sender")\n            }\n            from = txn.From\n        } else {\n            // only if we are in dev mode we can accept\n            // a transaction without validation\n            if !t.dev {\n                return fmt.Errorf("cannot accept non-encrypted txn")\n            }\n        }\n\n        t.logger.Debug("add txn", "ctx", ctx, "hash", txn.Hash, "from", from)\n    }\n\n    txnsQueue, ok := t.queue[from]\n    if !ok {\n        stateRoot := t.store.Header().StateRoot\n\n        // initialize the txn queue for the account\n        txnsQueue = newTxQueue()\n        txnsQueue.nextNonce = t.store.GetNonce(stateRoot, from)\n        t.queue[from] = txnsQueue\n    }\n    for _, txn := range txns {\n        txnsQueue.Add(txn)\n    }\n\n    for _, promoted := range txnsQueue.Promote() {\n        t.sorted.Push(promoted)\n    }\n    return nil\n}\n')),Object(a.b)("p",null,"The ",Object(a.b)("strong",{parentName:"p"},Object(a.b)("em",{parentName:"strong"},"addImpl"))," method is the bread and butter of the ",Object(a.b)("strong",{parentName:"p"},"TxPool")," module.\nIt is the central place where transactions are added in the system, being called from the GRPC service, JSON RPC endpoints,\nand whenever the client receives a transaction through the ",Object(a.b)("strong",{parentName:"p"},"gossip")," protocol."),Object(a.b)("p",null,"It takes in as an argument ",Object(a.b)("strong",{parentName:"p"},"ctx"),", which just denotes the context from which the transactions are being added (GRPC, JSON RPC...). ",Object(a.b)("br",null),"\nThe other parameter is the list of transactions to be added to the pool."),Object(a.b)("p",null,"The key thing to note here is the check for the ",Object(a.b)("strong",{parentName:"p"},"From")," field within the transaction:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"If the ",Object(a.b)("strong",{parentName:"li"},"From")," field is ",Object(a.b)("strong",{parentName:"li"},"empty"),", it is regarded as an unencrypted / unsigned transaction. These kinds of transactions are only\naccepted in development mode"),Object(a.b)("li",{parentName:"ul"},"If the ",Object(a.b)("strong",{parentName:"li"},"From")," field is ",Object(a.b)("strong",{parentName:"li"},"not empty"),", that means that it's a signed transaction, so signature verification takes place")),Object(a.b)("p",null,"After all these validations, the transactions are considered to be valid."),Object(a.b)("h2",{id:"data-structures"},"Data structures"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-go",metastring:'title="txpool/txpool.go"',title:'"txpool/txpool.go"'},"// TxPool is a pool of transactions\ntype TxPool struct {\n    logger hclog.Logger\n    signer signer\n\n    store      store\n    idlePeriod time.Duration\n\n    queue map[types.Address]*txQueue\n    sorted *txPriceHeap\n\n    // network stack\n    network *network.Server\n    topic   *network.Topic\n\n    sealing  bool\n    dev      bool\n    NotifyCh chan struct{}\n\n    proto.UnimplementedTxnPoolOperatorServer\n}\n")),Object(a.b)("p",null,"The fields in the TxPool object that can cause confusion are the ",Object(a.b)("strong",{parentName:"p"},"queue")," and ",Object(a.b)("strong",{parentName:"p"},"sorted")," lists."),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"queue")," - Heap implementation of a sorted list of account transactions (by nonce)"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"sorted")," - Sorted list for all the current promoted transactions (all executable transactions). Sorted by gas price")))}p.isMDXComponent=!0}}]);